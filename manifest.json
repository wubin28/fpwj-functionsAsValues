{"cyber-dojo.sh":"rm -f *.class\nCLASSES=.:`ls /junit/*.jar | tr '\\n' ':'`\njavac -Xlint:unchecked -Xlint:deprecation -cp $CLASSES  *.java\nif [ $? -eq 0 ]; then\n  # run test classes even if they are inner classes\n  # remove voluminous stack trace from output\n  java -cp $CLASSES org.junit.runner.JUnitCore `ls -1 *Test*.class | grep -v '\\\\$' | sed 's/\\(.*\\)\\..*/\\1/'` | grep -Ev 'org.junit.runner|org.junit.internal|sun.reflect|org.junit.Assert|java.lang.reflect|org.hamcrest'\nfi\n","output":"ProfitFPTest.java:52: error: cannot find symbol\n                (time) -> sales.valueAt(time) -\n                               ^\n  symbol:   method valueAt(int)\n  location: variable sales of type IntToDoubleFunction\nProfitFPTest.java:53: error: cannot find symbol\n                (fixedCosts.valueAt(time) +\n                           ^\n  symbol:   method valueAt(int)\n  location: variable fixedCosts of type IntToDoubleFunction\nProfitFPTest.java:54: error: cannot find symbol\n                        incrementalCosts.valueAt(time));\n                                        ^\n  symbol:   method valueAt(int)\n  location: variable incrementalCosts of type IntToDoubleFunction\nProfitFPTest.java:59: error: cannot find symbol\n            totalProfits += profit.valueAt(time);\n                                  ^\n  symbol:   method valueAt(int)\n  location: variable profit of type IntToDoubleFunction\n4 errors\n","instructions":"Java Functional Programming by Jessica Kerr\n\nfunctions as values\n\n","MinimumLambdaExamples.java":"\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.IntToDoubleFunction;\n\npublic class MinimumLambdaExamples {\n\n    public static void main(final String[] args) {\n\n        IntToDoubleFunction incrementalCosts = time -> 5.1 + 0.15 * time;\n\n        Function<String, Integer> wordCount = \n            (String s) -> s.split(\" \").length;\n\n        BiFunction<String, Integer, Boolean> exceedsMaxLength = \n            (s, maxLength) -> {\n                int actualLength = s.length();\n                return actualLength > maxLength;\n        };\n    }\n\n}\n","FunctionOverTime.java":"\n@FunctionalInterface\npublic interface FunctionOverTime {\n\n    double valueAt(int time);\n\n}\n","ProfitFPTest.java":"import org.junit.*;\nimport static org.junit.Assert.*;\nimport java.util.function.IntToDoubleFunction;\n\npublic class ProfitFPTest {\n    @Test\n    public void should_calculate_total_profits_for_the_year_in_FunctionOverTime() {\n        // given\n        final double[] EXPECTED_SALES_JAN_TO_DEC =\n            new double[] { 42.0, 45.6, 43.6, 50.2, 55.6, 54.7,\n                    58.0, 57.3, 62.0, 60.3, 71.2, 88.8};\n        final FunctionOverTime sales =\n                (time) -> EXPECTED_SALES_JAN_TO_DEC[time - 1];\n\n        final FunctionOverTime fixedCosts =\n                (time) -> 15.0;\n\n        final FunctionOverTime incrementalCosts =\n                (time) -> 5.1 + 0.15 * time;\n\n        final FunctionOverTime profit =\n                (time) -> sales.valueAt(time) -\n                (fixedCosts.valueAt(time) +\n                        incrementalCosts.valueAt(time));\n\n        // when\n        Double totalProfits = 0.0;\n        for(int time = 1; time <= 12; time ++) {\n            totalProfits += profit.valueAt(time);\n        }\n\n        // then\n        assertEquals(436.4, totalProfits, 0.001);\n    }\n\n    @Test\n    public void should_calculate_total_profits_for_the_year_in_IntToDoubleFunction() {\n        // given\n        final double[] EXPECTED_SALES_JAN_TO_DEC =\n            new double[] { 42.0, 45.6, 43.6, 50.2, 55.6, 54.7,\n                    58.0, 57.3, 62.0, 60.3, 71.2, 88.8};\n        final IntToDoubleFunction sales =\n                (time) -> EXPECTED_SALES_JAN_TO_DEC[time - 1];\n\n        final IntToDoubleFunction fixedCosts =\n                (time) -> 15.0;\n\n        final IntToDoubleFunction incrementalCosts =\n                (time) -> 5.1 + 0.15 * time;\n\n        final IntToDoubleFunction profit =\n                (time) -> sales.valueAt(time) -\n                (fixedCosts.valueAt(time) +\n                        incrementalCosts.valueAt(time));\n\n        // when\n        Double totalProfits = 0.0;\n        for(int time = 1; time <= 12; time ++) {\n            totalProfits += profit.valueAt(time);\n        }\n\n        // then\n        assertEquals(436.4, totalProfits, 0.001);\n    }\n}"}